<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>QFU Messaging • v2.5 (Markdown-safe)</title>
<style>
:root { --pad:14px; }
html,body{background:#f6f7fb}
body{font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:16px;max-width:980px;font-size:14pt}
h1{margin:0 0 12px}
.card{border:1px solid #ddd;border-radius:12px;padding:var(--pad);margin:12px 0;background:#fff}
label{display:block;font-weight:600;margin:10px 0 6px}
input,textarea{width:100%;box-sizing:border-box;padding:12px;border:1px solid #ccc;border-radius:10px;background:#fff}
.row{display:flex;gap:12px;flex-wrap:wrap}
.row>div{flex:1;min-width:240px}
.btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px;align-items:center}
button{border:1px solid #ccc;border-radius:999px;padding:10px 14px;background:#fff;cursor:pointer}
.pill{font-size:12px;background:#eef;border-radius:999px;padding:4px 8px;margin-left:6px}
pre.preview{white-space:pre-wrap;background:#fafafa;border:1px dashed #ccc;border-radius:10px;padding:12px;margin:6px 0}
.preview.done{border-color:#9ad29a;background:#f3fff3}
.status{margin-top:4px;display:inline-block}
.status.record-done{color:#0b7a0b;font-weight:600}
.hidden{display:none}
table{border-collapse:collapse;width:100%;margin-top:10px}
th,td{border:1px solid #eee;padding:8px;text-align:left}
th{background:#fafafa;font-weight:600}
tr.is-missing td{color:#a33}
.tiny{font-size:12px;opacity:.8}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
</style>
</head>
<body>
<h1>QFU Messaging <span class="pill">v2.5</span></h1>

<div class="card">
  <label for="blocks">Paste data (raw from Salesforce OR the Markdown version):</label>
  <textarea id="blocks" rows="14" class="mono" placeholder="[5043… - Name - BHxx xxx - (C3_01_155)](…)
£150.00
22HSP6
18/11/2025
[077…](tel:077…)
[+447…](tel:+447…)
[email@…](mailto:email@…)
<https://…>
-"></textarea>

  <div class="btns">
    <button id="btn-clean">Clean &amp; parse</button>
    <span class="tiny status" id="status"></span>
  </div>
</div>

<div class="card">
  <label>Parsed output:</label>
  <pre id="output" class="preview"></pre>
  <table id="summary" class="hidden">
    <thead>
      <tr>
        <th scope="col">Field</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
// 1. turn "[text](url)" into "text", and "<url>" into "url"
function normaliseIncoming(text) {
  if (!text) return "";
  let t = text;

  // unify newlines
  t = t.replace(/\r\n/g, "\n");

  // strip markdown links: [any text](any url) -> text
  t = t.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1");

  // strip angle brackets around links: <https://...> -> https://...
  t = t.replace(/<([^>]+)>/g, "$1");

  // trim extra spaces
  t = t.trim();

  return t;
}

// 2. your existing parser logic goes here
function processData(cleanText) {
  // this is a simple example based on the pattern you showed
  const lines = cleanText.split("\n").map(l => l.trim()).filter(Boolean);
  const parsed = {
    heading: lines[0] || "",
    price: lines.find(l => l.startsWith("£")) || "",
    product: lines.find(l => /^[A-Z0-9]{5,}$/.test(l)) || "",
    date: lines.find(l => /\d{2}\/\d{2}\/\d{4}/.test(l)) || "",
    phone: lines.find(l => /^0\d{9,}$/.test(l.replace(/\s+/g,""))) || "",
    mobile: lines.find(l => /^\+?\d{10,}$/.test(l.replace(/\s+/g,""))) || "",
    email: lines.find(l => /@/.test(l)) || "",
    portal: lines.find(l => /^https?:\/\//.test(l)) || ""
  };

  // show something friendly
  const fields = [
    { key: "heading", label: "Heading" },
    { key: "price", label: "Price" },
    { key: "product", label: "Product / Pack" },
    { key: "date", label: "Date" },
    { key: "phone", label: "Phone" },
    { key: "mobile", label: "Mobile" },
    { key: "email", label: "Email" },
    { key: "portal", label: "Portal" }
  ];
  const requiredKeys = new Set(["heading", "price", "product", "date", "email"]);

  const out = fields
    .map(field => `${field.label}: ${parsed[field.key] || ""}`)
    .join("\n");

  const outputEl = document.getElementById("output");
  const summaryTable = document.getElementById("summary");
  const tbody = summaryTable.querySelector("tbody");

  outputEl.textContent = out || "Paste data above to see parsed fields.";
  outputEl.classList.toggle("done", lines.length > 0);

  tbody.innerHTML = "";
  let missing = [];
  fields.forEach(({ key, label }) => {
    const value = parsed[key];
    const row = document.createElement("tr");
    if (!value && requiredKeys.has(key)) {
      row.classList.add("is-missing");
      missing.push(label);
    }

    const fieldCell = document.createElement("th");
    fieldCell.setAttribute("scope", "row");
    fieldCell.textContent = label;

    const valueCell = document.createElement("td");
    valueCell.textContent = value || "";

    row.appendChild(fieldCell);
    row.appendChild(valueCell);
    tbody.appendChild(row);
  });

  summaryTable.classList.toggle("hidden", lines.length === 0);

  const statusEl = document.getElementById("status");
  statusEl.textContent = lines.length
    ? missing.length === 0
      ? `Parsed ${lines.length} line(s) • all key fields found`
      : `Parsed ${lines.length} line(s) • missing: ${missing.join(", ")}`
    : "";
  statusEl.classList.toggle("record-done", lines.length > 0 && missing.length === 0);
}

document.getElementById("btn-clean").addEventListener("click", () => {
  const ta = document.getElementById("blocks");
  const raw = ta.value;
  const clean = normaliseIncoming(raw);
  ta.value = clean;           // show the cleaned version
  processData(clean);
});

// bonus: if user pastes, auto-clean once
document.getElementById("blocks").addEventListener("paste", (evt) => {
  // give iOS/Safari time to actually insert the text
  setTimeout(() => {
    const ta = document.getElementById("blocks");
    const clean = normaliseIncoming(ta.value);
    ta.value = clean;
    processData(clean);
  }, 30);
});
</script>
</body>
</html>
