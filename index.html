<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>QFU Messaging • v2.5 (Markdown-safe)</title>
<style>
:root { --pad:14px; }
html,body{background:#f6f7fb}
body{font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:16px;max-width:980px;font-size:14pt}
h1{margin:0 0 12px}
.card{border:1px solid #ddd;border-radius:12px;padding:var(--pad);margin:12px 0;background:#fff}
label{display:block;font-weight:600;margin:10px 0 6px}
input,textarea{width:100%;box-sizing:border-box;padding:12px;border:1px solid #ccc;border-radius:10px;background:#fff}
.row{display:flex;gap:12px;flex-wrap:wrap}
.row>div{flex:1;min-width:240px}
.btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px;align-items:center}
button{border:1px solid #ccc;border-radius:999px;padding:10px 14px;background:#fff;cursor:pointer}
.pill{font-size:12px;background:#eef;border-radius:999px;padding:4px 8px;margin-left:6px}
pre.preview{white-space:pre-wrap;background:#fafafa;border:1px dashed #ccc;border-radius:10px;padding:12px;margin:6px 0}
.preview.done{border-color:#9ad29a;background:#f3fff3}
.status{margin-top:4px;display:inline-block}
.status.record-done{color:#0b7a0b;font-weight:600}
.hidden{display:none}
table{border-collapse:collapse;width:100%;margin-top:10px}
th,td{border:1px solid #eee;padding:8px;text-align:left}
th{background:#fafafa;font-weight:600}
tr.is-missing td{color:#a33}
.tiny{font-size:12px;opacity:.8}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
</style>
</head>
<body>
<h1>QFU Messaging <span class="pill">v2.5</span></h1>

<div class="card">
  <label for="blocks">Paste data (raw from Salesforce OR the Markdown version):</label>
  <textarea id="blocks" rows="14" class="mono" placeholder="[5043… - Name - BHxx xxx - (C3_01_155)](…)
£150.00
22HSP6
18/11/2025
[077…](tel:077…)
[+447…](tel:+447…)
[email@…](mailto:email@…)
<https://…>
-"></textarea>

  <div class="btns">
    <button id="btn-clean">Clean &amp; parse</button>
    <span class="tiny status" id="status"></span>
  </div>
</div>

<div class="card">
  <label>Parsed output:</label>
  <pre id="output" class="preview">Paste data above to see parsed fields.</pre>
  <table id="summary" class="hidden">
    <thead>
      <tr>
        <th scope="col">Field</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
// 1. turn "[text](url)" into "text", and "<url>" into "url"
function normaliseIncoming(text) {
  if (!text) return "";
  let t = text;

  // unify newlines
  t = t.replace(/\r\n?/g, "\n");

  // strip markdown links: [any text](any url) -> text
  t = t.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1");

  // strip angle brackets around links: <https://...> -> https://...
  t = t.replace(/<([^>]+)>/g, "$1");

  // trim extra spaces
  t = t.trim();

  return t;
}

function unique(items, normaliser) {
  const seen = new Set();
  const results = [];
  items.forEach((item) => {
    const key = normaliser(item);
    if (!key) return;
    if (seen.has(key)) return;
    seen.add(key);
    results.push(item);
  });
  return results;
}

function normalisePhoneForCompare(text) {
  const digits = text.replace(/[^+\d]/g, "").replace(/^0+/, "0");
  return digits.length >= 10 ? digits : "";
}

// 2. existing parser logic with markdown-safe cleaning
function processData(cleanText) {
  const rawLines = cleanText
    .split("\n")
    .map((l) => l.trim())
    .filter(Boolean);
  const lines = rawLines.filter((line) => !/^[-–—•]+$/.test(line));

  const parsed = {
    heading: "",
    lead: "",
    name: "",
    postcode: "",
    product: "",
    price: "",
    offer: "",
    date: "",
    phone: "",
    mobile: "",
    email: "",
    portal: ""
  };

  if (lines.length) {
    const headingLine = lines[0];
    parsed.heading = headingLine;

    const productMatch = headingLine.match(/\(([^)]+)\)/);
    if (productMatch) {
      parsed.product = productMatch[1].trim();
    }

    const headingWithoutProduct = headingLine.replace(/\s*\([^)]+\)/, "").trim();
    const headerParts = headingWithoutProduct
      .split(/\s+-\s+/)
      .map((part) => part.trim())
      .filter(Boolean);

    if (headerParts.length) {
      const leadMatch = headerParts[0].match(/\b\d[\dA-Z-]*\b/);
      parsed.lead = leadMatch ? leadMatch[0] : headerParts[0];
    }
    if (headerParts.length > 1) {
      parsed.name = headerParts[1];
    }
    if (headerParts.length > 2) {
      parsed.postcode = headerParts[2];
    }
  }

  const priceLine = lines.find((line) => /£\s?\d/.test(line));
  if (priceLine) {
    const priceMatch = priceLine.match(/£\s?[\d,.]+/);
    parsed.price = priceMatch ? priceMatch[0].replace(/\s+/g, "") : priceLine;
  }

  const offerLine = lines.find((line) => /^[A-Z0-9]{4,}$/i.test(line.replace(/\s+/g, "")) && !/@/.test(line));
  if (offerLine) {
    parsed.offer = offerLine.replace(/\s+/g, "");
  }

  const dateLine = lines.find((line) => /\b\d{2}[\/\-]\d{2}[\/\-]\d{4}\b/.test(line));
  if (dateLine) {
    const dateMatch = dateLine.match(/\b\d{2}[\/\-]\d{2}[\/\-]\d{4}\b/);
    parsed.date = dateMatch ? dateMatch[0].replace(/-/g, "/") : dateLine;
  }

  const phoneCandidates = lines.filter((line) => {
    if (/£/.test(line) || /@/.test(line) || /https?:\/\//i.test(line)) return false;
    if (/\b\d{2}[\/\-]\d{2}[\/\-]\d{4}\b/.test(line)) return false;
    const digits = line.replace(/\D/g, "");
    return digits.length >= 10 && digits.length <= 13 && /^[+0]/.test(line.replace(/\s+/g, ""));
  });

  const uniquePhones = unique(phoneCandidates, normalisePhoneForCompare);
  if (uniquePhones.length) {
    const localPhone = uniquePhones.find((line) => line.replace(/\s+/g, "").startsWith("0"));
    const intlPhone = uniquePhones.find((line) => line.replace(/\s+/g, "").startsWith("+"));

    parsed.phone = localPhone || uniquePhones[0] || "";
    parsed.mobile = intlPhone || uniquePhones.find((line) => line !== parsed.phone) || "";

    if (parsed.phone && parsed.mobile && parsed.phone === parsed.mobile) {
      parsed.mobile = uniquePhones.find((line) => line !== parsed.phone) || "";
    }
  }

  const emailLine = lines.find((line) => /@/.test(line));
  if (emailLine) {
    const emailMatch = emailLine.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
    parsed.email = emailMatch ? emailMatch[0] : emailLine;
  }

  const portalLine = lines.find((line) => /https?:\/\//i.test(line));
  if (portalLine) {
    const portalMatch = portalLine.match(/https?:\/\/\S+/i);
    parsed.portal = portalMatch ? portalMatch[0].replace(/[)>]+$/, "") : portalLine;
  }

  const fields = [
    { key: "heading", label: "Heading" },
    { key: "lead", label: "Lead ID" },
    { key: "name", label: "Name" },
    { key: "postcode", label: "Postcode" },
    { key: "product", label: "Product / Pack" },
    { key: "price", label: "Price" },
    { key: "offer", label: "Offer Code" },
    { key: "date", label: "Proposed Date" },
    { key: "phone", label: "Primary Phone" },
    { key: "mobile", label: "Secondary Phone" },
    { key: "email", label: "Email" },
    { key: "portal", label: "Portal Link" }
  ];

  const requiredKeys = new Set(["lead", "name", "price", "offer", "date", "email", "portal"]);

  const out = fields
    .map((field) => `${field.label}: ${parsed[field.key] || ""}`)
    .join("\n")
    .trim();

  const outputEl = document.getElementById("output");
  const summaryTable = document.getElementById("summary");
  const tbody = summaryTable.querySelector("tbody");

  outputEl.textContent = out || "Paste data above to see parsed fields.";
  outputEl.classList.toggle("done", lines.length > 0);

  tbody.innerHTML = "";
  const missing = [];
  fields.forEach(({ key, label }) => {
    const value = parsed[key];
    const row = document.createElement("tr");
    if (!value && requiredKeys.has(key)) {
      row.classList.add("is-missing");
      missing.push(label);
    }

    const fieldCell = document.createElement("th");
    fieldCell.setAttribute("scope", "row");
    fieldCell.textContent = label;

    const valueCell = document.createElement("td");
    valueCell.textContent = value || "";

    row.appendChild(fieldCell);
    row.appendChild(valueCell);
    tbody.appendChild(row);
  });

  summaryTable.classList.toggle("hidden", lines.length === 0);

  const statusEl = document.getElementById("status");
  statusEl.textContent = lines.length
    ? missing.length === 0
      ? `Parsed ${lines.length} line(s) • all key fields found`
      : `Parsed ${lines.length} line(s) • missing: ${missing.join(", ")}`
    : "";
  statusEl.classList.toggle("record-done", lines.length > 0 && missing.length === 0);
}

document.getElementById("btn-clean").addEventListener("click", () => {
  const ta = document.getElementById("blocks");
  const raw = ta.value;
  const clean = normaliseIncoming(raw);
  ta.value = clean; // show the cleaned version
  processData(clean);
});

// bonus: if user pastes, auto-clean once
document.getElementById("blocks").addEventListener("paste", () => {
  // give iOS/Safari time to actually insert the text
  setTimeout(() => {
    const ta = document.getElementById("blocks");
    const clean = normaliseIncoming(ta.value);
    ta.value = clean;
    processData(clean);
  }, 30);
});
</script>
</body>
</html>
